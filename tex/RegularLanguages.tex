\setchapterpreamble[u]{\margintoc}
\chapter{Регулярные языки}

В данном разделе мы обсудим регулярные языки~--- класс, лежащий на самом нижнем уровне иерархии Хомского.
Будут рассмотрены основные способы задания таких языков: \emph{регулярные выражения}, \emph{конечные автоматы}, \emph{лево(право)линейные грамматики}.
Обсудим основные свойства регулярных языков, такие как замкнутость относительно различных операций, а также различные свойства соответствующих автоматов и грамматик.

\section{Регулярные выражения}

Регулярные выражения~--- один из классических способов задать регулярный язык%
\sidenote{
    Замечание для программистов.
    Важно понимать, что речь идёт о формальной конструкции, а не о том, что называется регулярными выражениями в различных языках программирования или библиотеках, где под названием \enquote{регулярные выражения} могут скрываться конструкции, существенно более выразительные, чем обсуждаемые здесь.
}.
Основывается этот способ на предложении синтаксиса для описания \emph{регулярных множеств}%
\sidenote{Помним, что язык~--- это множество слов.}.

\begin{definition}[Регулярное множество]
    Регулярное множество (над алфавитом $\Sigma$) это:
    \begin{itemize}
        \item $\varnothing$;
        \item $\{\varepsilon\}$;
        \item $\{t\}$, $t \in \Sigma$;
        \item $R_1 \cup R_2$, где $R_1$ и $R_2$~--- регулярные множества;
        \item $R_1 \cdot R_2$, где $R_1$ и $R_2$~--- регулярные множества;
        \item $R^*$, где $R$~--- регулярное множество.
    \end{itemize}
\end{definition}

Для того, чтобы описывать такие множества, удобно пользоваться \emph{регулярными выражениями}.

\begin{definition}[Регулярное выражение]
    Регулярное выражение (над алфавитом $\Sigma$) это:
    \begin{itemize}
        \item $\varnothing$;
        \item $\varepsilon$;
        \item $t$, $t \in \Sigma$;
        \item $R_1 \mid R_2$, где $R_1$ и $R_2$~--- регулярные выражения;
        \item $R_1 \cdot R_2$, где $R_1$ и $R_2$~--- регулярные выражения;
        \item $R^*$, где $R$~--- регулярное выражение;
        \item $(R)$, где $R$~--- регулярное выражение.
    \end{itemize}
\end{definition}

Отметим несколько важных с прикладной точки зрения моментов.
Во-первых, часто используется расширенный синтаксис, в который добавляются конструкции не увеличивающие выразительную силу, но упрощающие запись.
Например, встречаются следующие расширения%
\sidenote{
    Существуют и другие, однако их мы не будем использовать и, соответственно, рассматривать.
    Читатель может вспомнить, что называется регулярными выражениями в его любимом языке программирования и попробовать самостоятельно выразить имеющиеся там конструкции через базовые.}.
\begin{itemize}
    \item $R? = R \mid \varepsilon$, где $R$~--- регулярное выражение.
    \item $R^+ = R \cdot R^*$, где $R$~--- регулярное выражение.
\end{itemize}

Во-вторых, конструкции $\varnothing$ и $\varepsilon$ используются крайне редко, особенно в случае расширенного синтаксиса, так как часто выражение, эквивалентное использующему данные конструкции, часто более компактно записывается с использованием расширенного синтаксиса.
В-третьих, оператор конкатенации часто опускается%
\sidenote{Как и знак умножения во многих математических записях.}.

Рассмотрим несколько примеров регулярных выражений.
\begin{example}
    Регулярное выражение $a$ задаёт регулярное множество $\{a\}$ и, соответственно, язык из единственного слова $a$.
\end{example}

\begin{example}
    Регулярное выражение $ab$ задаёт регулярное множество $\{ab\}$ и, соответственно, язык из единственного слова $ab$.
\end{example}


\begin{example}
    Регулярное выражение $a^*$ задаёт регулярное множество $$R = \bigcup_{i=0}^{\infty}{a^i} = \{\varepsilon, a, aa, aaa, \ldots \}$$ и, соответственно, бесконечный язык, содержащий для любого неотрицательного целого $n$ цепочку из символов $a$ длины $n$.
\end{example}


\begin{example}
    $a^*b$
\end{example}

\begin{example}
    $(a\mid b)^*$
\end{example}

\begin{example}
    $(ab)^*c?$
\end{example}

\section{Конечные автоматы}

\emph{Конечный автомат}~--- вычислительная машина, которая имеет конечный набор состояний и может совершать переходы между ними, читая входные данные.
Важно отметить, что ни какой дополнительной памяти классический конечный автомат не имеет%
\sidenote{Существуют автоматы с константной памятью, регистрами} и не производит дополнительных действий%
\sidenote{Автоматы с записью на ленту, и т.д.}.

\begin{definition}[Недетерминированный конечный автомат]
    \label{def:NondeterminicticFiniteAutomata}
    \emph{Недетерминированный конечный автомат} (НКА)~--- это пятёрка $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$, где
    \begin{itemize}
        \item $Q$~--- конечное множество состояний;
        \item $Q_S \subseteq= Q$~--- множество стартовых состояний;
        \item $Q_F \subseteq Q$~--- множество финальных состояний;
        \item $\delta \subseteq Q \times (\Sigma \cup \varepsilon) \times 2^Q$~--- функция переходов, а $\varepsilon \notin \Sigma$;
        \item $\Sigma$~--- конечный алфавит.
    \end{itemize}
\end{definition}

Так как нас интересуют конечные автоматы в контексте языков, то будем говорить, что на ленте автомата записано какое-то слово (или строка).
Иными словами, будем говорить, что автомат принимает на вход слово или строку.

Процесс вычислений, проделываемых конечным автоматом, удобно описывать в терминах переходов между \emph{конфигурациями}.

\begin{definition}[Конфигурация]
    Конфигурация $c$ конечного автомата $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$~--- это пара $(q, w)$, где $q\in Q$~--- это текущее состояние автомата, а $w \in \Sigma^*$~--- непросмотренная часть входной строки.
\end{definition}

\begin{definition}[Переход в НКА]
    Будем говорить, что автомат $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$ может перейти из конфигурации $c_1 = (q_1, w_1)$ в конфигурацию $c_2 = (q_2, w_2)$, если
    \[c_2 \in \{(q_2,w_2) \mid w_1 = aw_2, (q_1,a, q_2) \in \delta\} \cup \{(q_2,w_1) \mid (q_1, \varepsilon, q_2) \in \delta\}.\]
    Обозначать этот факт будем как $c_1 \to c_2$.
\end{definition}

\marginnote{TODO: Без идей что тут написано, но жирная стрелочка для перехода выглядит естественнее}
$$С_2 = \{(q_2,w_2) \mid w_1 = aw_2, (q_1,a, q_2) \in \delta\} \cup \{(q_2,w_1) \mid (q_1, \varepsilon, q_2) \in \delta\}.$$
$$ c_1 \Rightarrow C_2 $$


Стартовая конфигурация.

Финальная конфигурация.

Ошибочная конфигурация.

\begin{example}
    Пример интерпретации конечного автомата.
\end{example}

\begin{definition}[Детерминированный конечный автомат]
    \label{def:DeterminicticFiniteAutomata}
    \emph{Детерминированный конечный автомат} (ДКА, Deterministic Finite Automata, DFA)~--- это пятёрка $M = \langle Q, q_S, Q_F, \delta, \Sigma \rangle$, где
    \begin{itemize}
        \item $Q$~--- конечное множество состояний;
        \item $q_S \in Q$~--- стартовое состояние;
        \item $Q_F \subseteq Q$~--- множество финальных состояний;
        \item $\delta \subseteq Q \times \Sigma \times Q$~--- функция переходов;
        \item $\Sigma$~--- конечный алфавит.
    \end{itemize}
\end{definition}

Заметим, что функцию переходов можно представить разными способами в зависимости от того, как именно представлена функция переходов: список троек, матрица, граф.

\begin{example}
    Пример КА.
    % \begin{tikzpicture}

    % \end{tikzpicture}
\end{example}

\begin{example}
    Пример интерпретации конечного автомата.
\end{example}

Построение КА по регулярному выражению и регулярному выражению по КА. На производных.

Построение регулярного выражения по КА.

Алгоритмы: проверка пустоты ...

Примеры.


\section{Лево(право)линейные грамматики}

Наложив некоторые ограничения на внешний вид правил грамматики можно получить грамматики, задающие регулярные языки.

\begin{definition}[Леволинейная грамматика]
    Грамматика $G=\langle \Sigma, N, P, S \rangle$ называется леволиненйной, если все её правила имеют вид
    \[N_i \to \alpha w,\]
    где $N_i \in N$, $\alpha \in \{\varepsilon\} \cup N$, $w \in \Sigma ^*$.
\end{definition}

\begin{definition}[Праволинейная грамматика]
    Грамматика $G=\langle \Sigma, N, P, S \rangle$ называется праволиненйной, если все её правила имеют вид
    \[N_i \to  w \alpha,\]
    где $N_i \in N$, $\alpha \in \{\varepsilon\} \cup N$, $w \in \Sigma ^*$.
\end{definition}

Ноам Хомский и Джордж Миллер в работе~\sidecite{chomsky1958finite} показали, что лево(право)линейные грамматики задают регулярные языки.
Приведём процедуры построения автомата по грамматике и наоборот, грамматики по автомату.

Пусть дан конечный автомат $M = \langle \Sigma, Q, q_s, Q_f, \delta \rangle$. По нему можно построить праволинейную грамматику $G=\langle \Sigma, N, S, P \rangle$, где
\begin{itemize}
    \item $N = Q$
    \item $P = \{ q_i \to t q_j \mid (q_i, t, q_j)\in \delta\} \cup \{ q_i \to \varepsilon \mid q_i \in Q_F\}$
    \item $S = q_s$
\end{itemize}

Аналогичным образом строится автомат по праволинейной грамматике.
Упростить процедуру можно если заранее привести правила к виду $N_i \to tN_j$, где $t\in \Sigma$, добавив необходимое количество новых нетерминалов:
правило вида $N_i \to twN_k$ преобразуется в два правила
\begin{align*}
    N_i & \to tN_l  \\
    N_l & \to wN_k,
\end{align*}
после чего аналогично преобразуется правило для $N_l$.

Пример построения грамматики по автомату.

Автомат по грамматике.

\section{Лемма о накачке}

Лемма о накачке для регулярных языков позволяет проверить, что заданный язык не является регулярным.

\begin{lemma}
    Пусть $L$~--- регулярный язык над алфавитом $\Sigma$, тогда существует такое $n$, что для любого слова $\omega \in L$, $|\omega| \geq n$ найдутся слова $x,y,z\in \Sigma^*$, для которых верно: $xyz = \omega, y\neq \varepsilon,|xy|\leq n$ и для любого $k \geq 0$  $xy^kz \in L$.
\end{lemma}

\begin{proofSketch}
    \begin{enumerate}
        \item Так как язык регулярный, то для него можно построить конечный автомат $M = \langle Q, q_s,Q_f, \delta, \Sigma \rangle$.
              В том числе, минимальный по количеству состояний.
        \item В качестве $n$ возьмём $|Q| + 1$.
        \item Легко заметить, что для любой цепочки $w \in L, |w| > n$ путь в автомате, соответствующий принятию данной цепочки, будет содержать хотя бы один цикл.
              Действительно, в ориентированном графе с $k$ вершинами (а именно таким является автомат по построению) максимальная длина пути без повторных посещений вершин (соответственно, без циклов) не больше $k - 1$.
        \item Выберем любой цикл. Он будет задавать искомые цепочки $x, y$ и $z$ так, как представлено на рисунке~\ref{fig:reg_lang_pumping_lemma}.
              Заметим, что вход в цикл и выход из него в общем случае могут не совпадать, что даёт несколько вариантов разбиения пути на части, и на рисунке представлен лишь один из возможных.
              \qedhere
    \end{enumerate}
\end{proofSketch}

\begin{figure}
    \caption{Иллюстрация идеи доказательства леммы о накачке для регулярных языков: любой путь в графе, длина которого достаточно большая, может быть разбит на три части из леммы ($x$~--- красный подпуть, $y$~--- синий, $z$~--- зелёный), а многократный проход по циклу $y$ позволяет \enquote{накачать} слово.}
    \label{fig:reg_lang_pumping_lemma}
    \begin{center}
        \begin{tikzpicture}[->]
            \node[state, initial] (q1) {$q_1$};
            \node[state, right = 2 of q1] (q2) {$q_2$};
            \node[state, accepting, right = 2 of q2] (q3) {$q_3$};
            \node[state, above = 2 of q2] (q4) {$q_4$};
            \draw (q1) edge[above, snake it] node{} (q2)
            (q2) edge[bend right, snake it, side by side={red}{blue}] node{} (q4)
            (q4) edge[bend right, snake it, color=blue] node[left]{$y$} (q2)
            (q4) edge[above, snake it, color=green] node[right]{$z$} (q3)
            (q1) edge[above, snake it, color=red] node{$x$} (q2)
            ;
        \end{tikzpicture}
    \end{center}

\end{figure}


\section{Замкнутость регулярных языков относительно операций}

\begin{theorem}
    Регулярные языки замкнуты относительно перечисленных ниже операций.
    \begin{enumerate}
        \item Пересечение
        \item Дополнение
        \item Обращение
        \item Разность
    \end{enumerate}
\end{theorem}

Линейная алгебра для работы с регулярными языками: пересечение, замыкание.

Построение пересечения через тензорное произведение автоматов.

Идея доказательства, что мы построили именно пересечение.

Пересечение через синхронный обход в ширину.

%\section{Вопросы и задачи}
%
%Построить базу.
%
%Научиться выполнять запросы через линейку.
